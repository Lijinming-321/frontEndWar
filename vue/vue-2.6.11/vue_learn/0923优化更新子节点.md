> 先外层循环newChildren数组，再内层循环oldChildren数组；每循环外层newChildren数组里的一个子节点，就去内层oldChildren数组里找看有没有与之相同的子节点，最后根据不同的情况作出不同的操作。
> 这样虽然可以解决问题。但是当子节点非常多时，循环算法的时间复杂度会变很大，不利于性能提升，vue对子节点更新做了优化

### 优化策略

- 假设有如下2个数组：
  
```js
    newChildren = ['新子节点1','新子节点2','新子节点3','新子节点4']
    oldChildren = ['旧子节点1','旧子节点2','旧子节点3','旧子节点4']
```

- 安装之前的更新策略，先循环newChildren,再循环oldChildren；最坏的情况我们需要循环16次，时间复杂度为O(n^2)

- 优化思路：
  - ![tu](https://vue-js.com/learn-vue/assets/img/8.e4c85c40.png)
    - newChildren数组里的所有未处理子节点的第一个子节点称为：新前；
    - newChildren数组里的所有未处理子节点的最后一个子节点称为：新后；
    - oldChildren数组里的所有未处理子节点的第一个子节点称为：旧前；
    - oldChildren数组里的所有未处理子节点的最后一个子节点称为：旧后；

  - newC[first] 和 oldC[first]比较，若相同直接进入更新节点操作
  - 若不相同，newC[last] 和 oldC[last]比较，若相同直接进入更新节点操作
  - 若不相同，newC[last] 和 oldC[first]比较，若相同直接进入更新节点操作，更新完成后再将oldC[first]移动到与newC[last]相同的位置
  - 若不相同，再把newC里未处理的节点里的第一个和oldC数组里未处理的节点的最后一个节点做比较，若相同，直接进入更新节点的操作，更新完后再将oldC数组里的该节点移动到newC数组里节点相同的位置
  - 最后四种情况试完，还不同，那按照之前循环的方式来查找节点


> 执行顺序👇

### 新前和旧前
- 只有比较过程
### 新后和旧后
- 只有比较过程
### 新后和旧前
- 比较过程
- 移动过程：<p style="color: orange;">oldChildren数组里把第一个子节点移动到数组中所有未处理节点之后</p>
### 新前和旧后
- 比较过程
- 移动过程：<p style="color: orange;">要把oldChildren数组里把最后一个子节点移动到数组中所有未处理节点之前</p>

### 以上四种情况逐个尝试后还没找到，就使用之前的循环方式查找


[源码分析](https://vue-js.com/learn-vue/virtualDOM/optimizeUpdataChildren.html#_6-%E6%96%B0%E5%89%8D%E4%B8%8E%E6%97%A7%E5%90%8E)

### 总结

- Vue中子节点更新的优化策略，发现Vue为了避免双重循环数据量大时间复杂度升高带来的性能问题，而选择了从子节点数组中的4个特殊位置互相比对，分别是：新前与旧前，新后与旧后，新后与旧前，新前与旧后。对于每一种情况我们都通过图文的形式对其逻辑进行了分析。最后我们回到源码，通过阅读源码来验证我们分析的是否正确。幸运的是我们之前每一步的分析都在源码中找到了相应的实现，得以验证我们的分析没有错。以上就是Vue中的patch过程，即DOM-Diff算法所有内容了