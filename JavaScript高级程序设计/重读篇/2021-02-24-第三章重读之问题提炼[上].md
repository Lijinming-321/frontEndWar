- 1.描述一下ECMAScript的变量？
  * ES的变量是松散类型的，变量可以保存任何类型的数据。
  * 3个关键字可以声明变量：var、let、const。
  * 每个变量只不过是一个用于保存任意值的命名占位符。

  * 其他角度
    - let 和 var 的区别
    - const 声明的变量

---

- 2.描述一下var声明？
  * 使用var操作符定义的变量会成为包含它的函数的局部变量。在函数内部定义的变量，在函数退出时被销毁；
  * var声明的范围是函数作用域；
  * 在函数内部，省略var定义变量，这个变量是全局变量。不推荐这样做，不好维护；
  * 严格模式下，禁止定义名为eval和arguments的变量；
  * var在全局作用域声明的变量会自动成为window的属性；

---

- 3.描述一下var的声明提升（hoist）？
  - 使用var关键字声明的变量会自动提升到函数作用域顶部。
  - 使用var重复声明同一个变量是没有问题的。
  - for循环定义的迭代变量会渗透到循环体外部。let不会

---

- 4.描述一下let声明？
  * let声明的范围是块作用域，不存在声明提升问题；
  * 块作用域是函数作用域的子集，因此适用于var的作用域同样适用于let；
  * 在同一个块级作用域内，禁止冗余声明；
  * 嵌套使用相同的标识符不会报错；
  * 对声明冗余报错不会因混用let和var而受影响。这两个关键字声明的并不是不同类型的变量。它们只是指出变量在相关作用域如何存在；
  * 在全局作用域下，let声明的变量不会成为window对象的属性；
  * 不能使用let进行条件声明是件好事，因为条件声明是一种反模式，它让程序变得更难理解；
  * 使用let声明迭代变量时，js引擎在后台会为每个迭代循环声明一个新的迭代变量。每个setTimeOut引用的都是不同的变量实例。
  * 适合for、for-in、for-of

---

- 5. 理解暂时性死区？
  - 在解析代码时，js引擎也会注意出现在块后面的let声明，只不过在此之前不能以任何方式来引用未声明的变量。在let声明之前的执行瞬间被称为“暂时性死区”temporal dead zone，在此阶段引用任何后面才声明的变量都会抛出ReferenceError。

---

- 6.理解const声明？
  * 行为与let基本相同。也是块作用域
  * 唯一区别就是声明变量时必须同时初始化变量且试图修改const声明的变量会导致错误。
  * const声明的限制只适用于它指向的变量的引用。
  * 当const变量引用的是对象时，修改该对象内部的属性不违反const限制。
  * 不要使用const来声明迭代遍历。
  * const声明的迭代遍历对for-of和for-in循环特别有用

--- 

- 7.ES有几种数据类型？
  * 原始类型
    - Undefined
    - Null
    - Boolean
    - Number
    - String
    - Symbol
  * 复杂类型
    - Object
  * 新增的原始类型
    - BigInt

---

- 8.判断变量数据类型的方式？
  - 1.第一步使用typeof操作符，可以判断除了Null之外的变量数据类型（包括函数），Null被归到Object里面；
  - 2.使用instanceof操作符，更精准的判断变量数据类型。

---

- 9.Undefined类型与Null类型的区别？
  * Undefined类型只有一个值，就是特殊值undefined。变量声明而为赋值，则相当于赋值了undefined；
  * ES新增undefined值得目的就是为了正式明确空对象指针null和未初始化变量的区别；
  * undefined值的变量跟未定义变量是有区别的；
  * undefined是一个假值；
  * Null只有一个值，就是特殊值null；表示一个空对象指针。所以typeof会把null判断成'object'；
  * 初始化对象，可以使用null来初始化；
  * undefined值是由null派生而来的，因此ES定义二者表面相等`null == undefined`；(其实是==会比较转换后的值)
  * null是一个假值；

---

- 10.描述不同类型与布尔值之间的转换关系？
  * 这2个布尔值不同于数值，因此true不等于1，false不等于0 (严格相等的情况下，===)

  | 数据类型 | 转换为true | 转换为false |
  | ---- | ----| ---- |
  | Boolean | true | false |
  | String | 非空字符串 | ""（空字符串） |
  | Number | 非零数值（包括无穷值） | 0、NaN（参见后面的相关内容） |
  | Object | 任意对象 | null |
  | Undefined | N/A（不存在） | undefined |

  * if会将参数自动转换相应的布尔值

---

- 11.理解Number类型？
  - 使用IEEE754格式表示整数和浮点数
  - 二进制、八进制（0开头）、十进制、十六进制（0x开头）
  - 在进行浮点数计算时，要考虑到浮点数的精度问题，设置合适的误差。
  - 值得范围
  - 特殊值NaN和isNaN()函数
  - 数值转换方式

--- 

- 12.数值转换方式？
  * Number()，转型函数，用于任何数据类型
  * parseInt()，主要用于字符串
  * parseFloat()，主要用于字符串
  * 三者转换规则描述。

--- 

- 13.字符串的特点？
  * 字符串是不可变的immutable，一旦创建值就不能变了。要修改只能先销毁原始字符串，然后将新字符串保存到该变量；
  * 所以早期浏览器拼接字符串是非常慢的。

---

- 14.转换成字符串的方式？
  * toString()，这个方法几乎所有值都有，返回当前值得字符串等价物。数值、布尔值、对象、字符串值
  * 使用+操作符，也可以。

--- 

- 15.理解模板字面量与字符串插值？
  * 模板字面量：保留换行字符，可以跨行定义字符串；
  * 模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的JavaScript句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。 `${value}`
  * 模板字面量标签函数
  * 原始字符串

---

- 16.描述Symbol类型和其作用？
  - ES6新增数据类型。符号是原始值，且符号实例是唯一、不可变的。
  - 符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。
  - symbol并不是为了提供私有属性的行为而新增的。
  - 符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。

- 17.描述Object类型？
  - ES中的对象其实是一组数据和功能的集合。
  - 对象通过new操作符后跟对象类型的名称来创建。
  - Object的实例本身并不是很有用，但是理解与它相关的概念非常重要。类似于Java中的java.lang.Object，ES中的Object也是派生其他对象的基类。
  - Object类的所有属性和方法在派生的对象上同样存在。

- 每个Object实例都有如下属性和方法：
  - constructor：用于创建当前对象的函数。这个属性的值就是Object()函数。
  - hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（o.hasOwnProperty("name")）或符号。
  - isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型
  - propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用for-in语句枚举。与hasOwnProperty()一样，属性名必须是字符串。
  - toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。
  - toString()：返回对象的字符串表示。
  - valueOf()： 返回对象对应的字符串、数值或布尔值表示。通常与toString()的返回值相同。

- 注意： 严格来讲，ES中对象的行为不一定适合js中的其他对象。比如浏览器环境中的BOM和DOM对象，都是由宿主环境定义和提供的宿主对象。
- 宿主对象不受ES约束，所以它们可能也可能不会继承Object。