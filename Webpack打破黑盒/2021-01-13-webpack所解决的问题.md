- webpack所解决的问题：
  - 如何在前端项目中更高效地管理个维护项目中的每一个资源

- 模块化的演进过程：
  - stage1-文件划分方式
    - 缺点：
      - 模块直接在全局工作，大量模块成员污染全局作用域
      - 没有私有空间，所有模块内的成员都可以在模块外部被访问或者修改
      - 一旦模块增多，容易产生命名冲突
      - 无法管理模块与模块之间的依赖关系
      - 在维护的过程中也很难分辨每个成员所属的模块
  - stage2-命名空间方式
    - 解决命名冲突问题，其他问题依旧存在
  - stage3-IIFE（立即执行函数）
    - 利用闭包，解决命名冲突和私有空间问题
  - stage4-IIFE依赖参数

- 模块加载的问题：
  - 更为理想的方式是在页面中引入一个JS入口文件，其余用到的模块可以通过代码控制，按需加载。

- 制定一个行业标准去规范模块化的实现方式：为了统一不同开发者、不同项目之间的差异。

- 模块化规范的出现：
  - 两点需求：
    - 一个统一的模块化标准规范
    - 一个可以自动加载模块的基础库

- CommonJS规范：
  - 是Node.js中遵循的模块规范，该规范约定一个文件就是一个模块，每个模块都有单独的作用域通过`module.exports`导出成员，再通过`require`函数载入模块

- 由于CommonJS规范下的模块导入方式是同步的，在浏览器端表现不佳。所以专门为浏览器端设计了一个规范AMD
- AMD：Asynchronous Module Definition，异步模块定义规范
- Require.js库，实现了AMD规范
  - define(): 定义模块，加载模块
  - require()：只能加载模块

- 前端模块化规范的最佳实践方式：
  - 在Node.js环境，遵循CommonJS规范来组织模块
  - 在浏览器环境中，遵循ES Modules规范

- 重点去掌握ESModules，是ECMAScript2015中才定义的模块系统

- 模块化打包工具：
  - 主流浏览器大都支持ES Modules
  - 模块化导致文件过多，频繁向浏览器请求数据，影响性能？
  - JS/CSS/HTML等资源都需要面临模块化的问题

- 这个工具具有的能力：
  - 编译能力，将ES6编译成ES5
  - 将散落的文件打包成一个文件
  - 支持不同种类的文件类型打包

- 前端模块化的发展过程和最终的统一的ESModules

- 模块化思想是统治整个前端项目的