- webpack的另一个高级特性，Code Splitting(分块打包)

- All in One的弊端
  - 将所有的代码打包到一起，若我们的应用非常复杂，模块非常多，那么这种all in one 的方式就会导致打包的结果过大，甚至超过4~5M

- 当代码量非常大时，All in One的·方式并不合理，更合理的方案是把打包的结果按照一定的规划分离多个bundle中，然后根据应用的运行需要按需加载。这样可以降低启动成本，提高响应速度。

- web应用中的资源受环境所限制
  - 太大不行，太小不行
  - 打包是必要的

- 目前主流的HTTP 1.1本身就存在一些缺陷：
  - 同一个域名下的并行请求是有限制的；
  - 每次请求都会有一定的延迟；
  - 每次请求除了传输内容，还有额外的请求头，大量请求的情况下，这些请求头加载一起也会浪费流量和带宽

- 所有模块打包是必要的，但当应用体积越来越大时，我们要学会变通

### Code Splitting
- 为了解决打包结果过大导致的问题，webpack设计了一种分包功能：code splitting

- 降低成本，提高速率

- webpack实现分包的方式主要有两种：
  - 根据业务不同配置多个打包入口，输出多个打包结果
  - 结合ES Modules的动态导入，按需加载模块

- 多入口打包存在的一个小问题：
  - 不同的入口中一定会存在一些公共使用的模块
  - 如果按照目前这种多入口打包的方式，就会出现多个打包结果中有相同的模块的情况

- 提取公共模块
  - 在配置中添加
  ```js
  splitChunks: {
    chunks: 'all', // 自动提取所有公共模块到单独bundle
  }
  ```

- 动态导入
  - code splitting更常见的实现方式还是结合ES Modules的动态导入特性
  - 从而实现按需加载，指的是在应用运行过程中需要某个资源模块，才去加载这个模块
  - 极大地降低应用启动时需要加载的资源体积，提高了应用的响应速度，同时也节省了带宽和流量。

- 按照ES Modules动态导入语法实现按需加载，实现按需分包

- 魔法注释
  - `/* webpackChunkName: '<chunk-name>' */`
  - 若注释名相同，则打包到一个文件


- 从事开发工作：
  - 1.制造问题
  - 2.解决问题