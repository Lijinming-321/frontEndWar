- es6暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。

- let不允许在相同作用域内，重复声明同一个变量；因此不能在函数内部重新声明参数

- ES5只有全局作用域和函数作用域，没有块级作用域
  - 1、内层变量可能会覆盖外层变量
  - 用来计数的循环变量泄露为全局变量

- ES6允许块级作用域的任意嵌套
  - 各层的作用域互不干扰
  - 块级作用域的出现，实际上使得广泛应用的匿名函数立即执行函数表达式（IIFE）不再必要

  ```js
    // IIFE写法
    (function () {
        var tmp = ...;
        ...
    }());

    // 块级作用域写法
    let temp = ...;
    ...
  ```

- 块级作用域与函数声明
  - ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能再块级作用域声明

- ES6
  - 允许在块级作用域内声明函数。
  - 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
  - 同时，函数声明还会提升到所在的块级作用域的头部。
  - 注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。

- 根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。

- ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域

- const
  - const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动
  - 但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心
  - 将一个对象或者数组设置为常量，则其指针指向的地址是不变的，但仍可以为其添加新属性。

  ```js
    const a = []
    a.push('hello')
    a.length = 0;
    a = ['Dsve']//保错
  ```

  - 可以使用Object.freeze()将对象冻结
  
  ```js
    const foo = Object.freeze({});
  ```


- ES6声明变量的六种方法
  - ES5只有2种声明变量的方法：
      - var
      - function
  - ES6
      - let
      - const
      - import
      - class
      - var
      - function

- 顶层对象之属性
  - 在浏览器环境中指的是window对象
  - 在Node指的是global对象。
  - ES5中，顶层对象的属性与全局变量是等价的
  
  ```js
    window.a = 1;
    // a = 1
    a = 2;
    window.a // 2
  ```

  - 顶层对象的属性与全局变量挂钩，带来一些问题：
    - 1、没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）
    - 2、编程人员会不知不觉就创建了全局变量
    - 3、顶层对象的属性到处可读，不利于模块化编程
    - 4、window对象有实体含义：指的是浏览器的窗口对象
    - 5、顶层对象是一个有实体含义的对象，也是不合适的

  - ES6:
    - var、function声明的全局变量依旧属于顶层对象的属性
    - let、const、class、声明的变量不属于顶层对象的属性


- globalThis对象
  - js语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都在这个环境中运行。

    - 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
    - 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。
    - Node 里面，顶层对象是global，但其他环境都不支持

  - 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。
  - 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。
  - 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用