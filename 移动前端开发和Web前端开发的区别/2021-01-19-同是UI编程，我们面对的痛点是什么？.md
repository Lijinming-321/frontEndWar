### 传统Web前端技术的技术局限性

- 1.`资源加载`：HTML、JS、CSS、图片等静态资源存放在远端的服务器，需要动态的异步拉取，在拉取数据进行展示，初始化效率比Native慢的多。

- 2.`渲染机制`：在浏览器的设计中，JS的执行和页面的布局、Paint都在同一个主线程。，无法并行化，再加上JS性能赶不上AOT语言，执行复杂逻辑时导致的卡顿通常会阻塞UI，再加上冗长的渲染管线，导致浏览器的渲染体验再等量对比Native时并不占优势。

- 3.`页面切换`：在浏览器中并不存在路由的概念，这导致页面间的切换体验完全依赖于浏览器Shell 提供的能力，在页面切换的时候会反复加载。当然前端社区中也出现了单页面应用的概念，但是多个页面的资源也显著增加了 JSBundle 的体积，也使页面的开发更加复杂化了。

- 4.`API能力`：浏览器的安全机制是基于同源策略的沙箱机制，这套沙箱机制阻止了前端开发者使用原生系统能力，你只能使用 W3C 标准定义的功能，而且考虑到终端碎片化的问题，这些接口往往不能直接使用。这在 PC 端的场景中是没有什么问题的，但是在移动端则相反，开发者希望有能力调用系统接口实现一些更富交互的场景。

- 5.`交互性能`：浏览器的实时交互性能体验差，在复杂交互场景中大规模的重排限制了 UI帧率，这种限制在中低端移动设备中尤为严重。

- 6.`脚本语言，动态解析执行`：JS 是一门 JIT 语言，也就是需要动态解析执行，对比预先编译机器码的 AOT 语言的执行性能就差得多了。

### 传统客户端技术的局限性？

- 1.`动态性`：客户端开发通常是有固定的版本发布计划，而且受制于 Apple 的 App Store 审核规则，版本发布的不确定性还会受到政策影响，Android 在国内的渠道众多，每次发版都要反复检查渠道，一旦发现线上问题需要依赖再次发版，容错成本非常高，这也大大增加了对业务的局限性。

- 2.`开发成本`：客户端的开发成本高，然而生态还不如 Web 丰富，npm 社区的几万开源包，加上更活跃的开发者社区，导致对企业来讲客户端的研发成本是高于Web 开发的。

- 3.`跨端一致性`：传统客户端开发一套业务，是需要实现 Android + iOS 两套代码的，而且由于 Android 和 iOS 的操作系统能力差异，同样的需求往往会用不同的视觉和交互来实现，这也导致了业务成本居高不下。

### 混合式前端开发

#### 为什么会出现混合式前端开发？

- 1.Web的开发方式远比iOS和Android更加方便和高效，Web上的ku和框架非常丰富

- 2.业务需要追求快速发展，前台的UI和需求会随着商业决策快速迭代，要求前端必须快速开发

- 3.前端向上，前置作为业务方的唯一接口，逐渐演变为大前端的业务层。在这一层，它的职责
是负责定义规范，通过框架规范业务的开发过程，同时封装统一的解决方案和工程化能力，将重复的工作抽离。

- 4.客户端向下，解耦业务需求，转为大前端的架构层，给上层的业务开发者提供能力支持。通过将客户端的系统级 API 以及宿主应用的能力暴露给上层前端，提高前端页面对更多富交互场景的承载能力。

- 从`前端开发和客户端开发并行`，转变成`客户端开发——>前端开发——>业务`

#### 混合式应用的发展定义为三个阶段：

- 阶段一：JSBridge
  - 主要还是以WebView为主，并配合JSBridge提供了Native与JS之间的通信链路，基于这个通信链路，Native可以暴露出一些标准服务API提供给JS调用，同样的JS也可以封装一些基础API给Native调用。
  - 前端开发者使用传统JS + HTML + CSS 进行页面的开发，并且调用 JSBridge API 驱动客户端能力。
  - 缺点：
    - 性能不佳
    - 高级组件扩展能力缺失
    - 流畅性始终无法与Native相比

- 阶段二：原生UI
  - 虽然Web的动态性和高效的开发速率是原生开发无法比及的，但是浏览器技术的瓶颈也是非常明显的：
    - 1.W3C 作为开放的技术标准，历史悠久，包袱多，显著拖慢了浏览器的性能。
    - 2.WebView 渲染引擎设计的上的缺陷，渲染流水线非常长，导致浏览器对合成器动画和非合成器动画区别对待，非合成动画性能不好。
    - 3.单线程模型，无法发挥现代硬件架构特别是ARM架构多核心的性能。
    - 4.异步光栅化的设计，在进行长列表滚动时，不可避免出现白屏的现象。

  - RN/weex利用JS引擎来调用Native端的组件，从而实现相应的功能。React Native 和Weex 都允许前端开发者使用 JS 进行业务逻辑开发，使用VDOM 来描述文档结构，并配合 CSS 的子集来定制样式，样式和模板分离。

- 阶段三：自绘引擎
  - 就是不依赖操作系统提供的布局、原生组件能力，直接调用GPU或者底层抽象层进行绘制的渲染引擎。
  - 组件的封装成本随着复杂度增加也越来越高，难以逾越 Native View 限制提供更细致的 W3C 标准能力。
  - Flutter，通过 Dart 语言构建一套跨平台的开发组件，所有组件基于 Skia 引擎自绘，在性能上和 Native 平台的 View 相媲美，同时解决了上一代架构难以解决的双端一致性等问题。

- 未来：回归本源
  - 移动前端开发本质还是终端开发的一种形态，不管容器、框架、语言怎么变，W3C标准永远不变
  - PWA
  - PHA